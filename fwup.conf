# Default ROOTFS if not specified
define(ROOTFS, "${PROJECT_ROOT}/output/images/rootfs.ext2")
define(UNAME_R, "5.10.83-armv7-lpae-x58")

# Image layout
# +-------------------------+
# | MBR                     |
# +-------------------------+
# | FSBL 1                  |
# | for u-boot-spl.stm32    |
# +-------------------------+
# | FSBL 2                  |
# | for u-boot-spl.stm32    |
# +-------------------------+
# | SSBL for u-boot.img     |
# +-------------------------+
# | BOOT partition (FAT16)  |
# | uEnv.txt                |
# | *.dtb                   |
# +-------------------------+
# | Rootfs partition (EXT4) |
# +-------------------------+

# The First Stage Boot Loader 1
define(FSBL1_PART_OFFSET, 34)
define(FSBL1_PART_COUNT, 512) # 512 * 512 / 1024 = 256 KiB

# The First Stage Boot Loader 2
define(FSBL2_PART_OFFSET, 546)
define(FSBL2_PART_COUNT, 512) # 512 * 512 / 1024 = 256 KiB

# The Second Stage Boot Loader 2
define(SSBL_PART_OFFSET, 1058)
define(SSBL_PART_COUNT, 4096) # 4096 * 512 / 1024 / 1024 = 2 MiB

# The boot partition has room for a uEnv.txt. (Only about 1 MB)
define(BOOT_PART_OFFSET, 5154)
define(BOOT_PART_COUNT, 131072) # 131072 * 512 / 1024 / 1024 = 64 MiB

# Let the rootfs have room to grow up to 128 MiB (256K 512-byte blocks)
define(ROOTFS_PART_OFFSET, 136226)
define(ROOTFS_PART_COUNT, 262144) # 262144 * 512 / 1024 / 1024 = 128 MiB

# Firmware metadata
meta-product = "Image for the ODYSSEY_STM32MP157C"
meta-description = "This image boots to Linux."
meta-version = "0.1"
meta-platform = "odyssey_stm32mp157c"
meta-architecture = "arm"
meta-author = "Tombo Works"

# File resources are listed in the order that they are included in the .fw file
# This is important, since this is the order that they're written on a firmware
# update due to the event driven nature of the update system.
file-resource u-boot-spl.stm32.fsbl1 {
    host-path = "${PROJECT_ROOT}/output/images/u-boot-spl.stm32"
}
file-resource u-boot-spl.stm32.fsbl2 {
    host-path = "${PROJECT_ROOT}/output/images/u-boot-spl.stm32"
}
file-resource u-boot.img {
    host-path = "${PROJECT_ROOT}/output/images/u-boot.img"
}
file-resource uEnv.txt {
    host-path = "${BR2_EXTERNAL_ODYSSEY_STM32MP157C_PATH}/board/u-boot/uEnv.txt"
}
file-resource zImage {
    host-path = "${PROJECT_ROOT}/output/images/zImage"
}
file-resource stm32mp157c-seeed-npi.dtb {
    host-path = "${PROJECT_ROOT}/output/images/stm32mp157c-seeed-npi.dtb"
}
file-resource rootfs.img {
    host-path = ${ROOTFS}

    # Error out if the rootfs size exceeds the partition size
    assert-size-lte = ${ROOTFS_PART_COUNT}
}

gpt gpt {
    # UUID for the entire disk
    guid = 691f1be3-ec37-4dd2-b695-fe9901a93d63 # generated by uuidgen

    partition 0 {
        block-offset = ${FSBL1_PART_OFFSET}
        block-count = ${FSBL1_PART_COUNT}
        type = 0fc63daf-8483-4772-8e79-3d69d8477de4 # Linux filesystem type UUID
        guid = 9ecd363c-6af5-4648-b975-5b4cebef0f68 # generated by uuidgen
        name = "fsbl1"
    }
    partition 1 {
        block-offset = ${FSBL2_PART_OFFSET}
        block-count = ${FSBL2_PART_COUNT}
        type = 0fc63daf-8483-4772-8e79-3d69d8477de4 # Linux filesystem type UUID
        guid = f13c7240-fcdc-4b84-aecc-fd57dc6c27ed # generated by uuidgen
        name = "fsbl2"
    }
    partition 2 {
        block-offset = ${SSBL_PART_OFFSET}
        block-count = ${SSBL_PART_COUNT}
        type = 0fc63daf-8483-4772-8e79-3d69d8477de4 # Linux filesystem type UUID
        guid = 3b122046-ac67-4174-8ee8-0d2e9842fad4 # generated by uuidgen
        name = "ssbl"
    }
    partition 3 {
        block-offset = ${BOOT_PART_OFFSET}
        block-count = ${BOOT_PART_COUNT}
        type = 0fc63daf-8483-4772-8e79-3d69d8477de4 # Linux filesystem type UUID
        guid = bfc7baa5-8afb-4220-b03d-88d378e16e77 # generated by uuidgen
        name = "boot"
        boot = true
    }
    partition 4 {
        block-offset = ${ROOTFS_PART_OFFSET}
        block-count = ${ROOTFS_PART_COUNT}
        type = 0fc63daf-8483-4772-8e79-3d69d8477de4 # Linux filesystem type UUID
        guid = 5c58aef9-cc84-4d5e-a11f-4d18571ee5bb # generated by uuidgen
        name = "rootfs"
    }
}

# This firmware task writes everything to the destination media
task complete {
    # Only match if not mounted
    require-unmounted-destination = true

    # Everything that gets written can be verified on the fly.
    # This speeds things up, since we don't care about detecting
    # errors before data gets written.
    verify-on-the-fly = true

    on-init {
        gpt_write(gpt)

        fat_mkfs(${BOOT_PART_OFFSET}, ${BOOT_PART_COUNT})
        fat_setlabel(${BOOT_PART_OFFSET}, "BOOT")

        fat_mkdir(${BOOT_PART_OFFSET}, "dtbs")
        fat_mkdir(${BOOT_PART_OFFSET}, "dtbs/${UNAME_R}")
    }

    on-resource u-boot-spl.stm32.fsbl1 { raw_write(${FSBL1_PART_OFFSET}) }
    on-resource u-boot-spl.stm32.fsbl2 { raw_write(${FSBL2_PART_OFFSET}) }

    on-resource u-boot.img { raw_write(${SSBL_PART_OFFSET}) }

    on-resource uEnv.txt { fat_write(${BOOT_PART_OFFSET}, "uEnv.txt") }
    on-resource zImage { fat_write(${BOOT_PART_OFFSET}, "vmlinuz-${UNAME_R}") }
    on-resource stm32mp157c-seeed-npi.dtb {
        fat_write(${BOOT_PART_OFFSET}, "dtbs/${UNAME_R}/stm32mp157c-seeed-npi.dtb")
    }

    on-resource rootfs.img {
        # write to the first rootfs partition
        raw_write(${ROOTFS_PART_OFFSET})
    }

    on-finish {
    }
}
